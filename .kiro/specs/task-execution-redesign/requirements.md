# 任务执行与数据持久化重构需求文档

## 简介

本文档定义了 Open-AutoGLM GUI 应用中任务执行流程和数据持久化机制的完全重构需求。当前实现存在严重的架构问题，导致停止任务时数据丢失、状态不一致等问题。本次重构将从根本上解决这些问题。

## 术语表

- **任务执行器 (Task Executor)**: 负责管理任务生命周期的核心组件
- **数据持久化层 (Data Persistence Layer)**: 负责所有数据库操作的独立层
- **状态机 (State Machine)**: 管理任务状态转换的组件
- **步骤缓冲区 (Step Buffer)**: 临时存储步骤数据的内存缓冲区
- **同步写入 (Synchronous Write)**: 立即写入数据库的操作
- **批量提交 (Batch Commit)**: 将多个操作合并为一次数据库事务

## 问题分析

### 当前架构的严重问题

1. **异步写入导致数据丢失**
   - 步骤日志使用 QTimer 延迟 10ms 写入
   - 用户快速停止时，QTimer 还未触发，数据丢失
   - `_pending_step_logs` 计数器不可靠

2. **状态管理混乱**
   - 多个地方修改 `_current_session_id`
   - `_session_finalized` 标志不可靠
   - 停止后的信号仍会被处理

3. **数据库操作分散**
   - 数据库操作散落在多个方法中
   - 没有统一的事务管理
   - 错误处理不一致

4. **线程安全问题**
   - 主线程和工作线程都访问共享状态
   - 没有适当的锁机制
   - 信号槽连接方式不当

## 需求

### 需求 1: 任务状态机

**用户故事**: 作为系统，我需要一个清晰的状态机来管理任务生命周期，以确保状态转换的正确性和可预测性。

#### 验收标准

1. WHEN 任务创建 THEN 系统应将任务状态设置为 CREATED
2. WHEN 任务开始执行 THEN 系统应将状态从 CREATED 转换为 RUNNING
3. WHEN 任务正常完成 THEN 系统应将状态从 RUNNING 转换为 SUCCESS
4. WHEN 任务执行出错 THEN 系统应将状态从 RUNNING 转换为 FAILED
5. WHEN 用户停止任务 THEN 系统应将状态从 RUNNING 转换为 STOPPING，然后转换为 STOPPED
6. WHEN 状态转换无效 THEN 系统应拒绝转换并记录错误日志
7. WHEN 状态转换发生 THEN 系统应立即持久化新状态到数据库

### 需求 2: 同步数据持久化

**用户故事**: 作为系统，我需要确保所有关键数据立即写入数据库，以防止数据丢失。

#### 验收标准

1. WHEN 任务开始 THEN 系统应同步写入任务记录到数据库
2. WHEN 步骤完成 THEN 系统应同步写入步骤记录到数据库
3. WHEN 任务状态改变 THEN 系统应同步更新数据库中的状态
4. WHEN 数据库写入失败 THEN 系统应重试最多 3 次
5. WHEN 重试仍失败 THEN 系统应将数据写入本地备份文件
6. WHEN 数据库操作超时 THEN 系统应在 5 秒后超时并记录错误
7. WHEN 系统恢复 THEN 系统应从备份文件恢复未写入的数据

### 需求 3: 步骤缓冲区机制

**用户故事**: 作为系统，我需要一个可靠的步骤缓冲区来确保所有步骤数据都被正确保存。

#### 验收标准

1. WHEN 步骤开始 THEN 系统应在缓冲区中创建步骤记录
2. WHEN 步骤完成 THEN 系统应更新缓冲区中的步骤记录并立即写入数据库
3. WHEN 任务停止 THEN 系统应将缓冲区中所有步骤写入数据库
4. WHEN 缓冲区满 THEN 系统应批量写入数据库并清空缓冲区
5. WHEN 系统崩溃 THEN 系统应在重启时从缓冲区恢复数据
6. WHEN 缓冲区数据写入成功 THEN 系统应从缓冲区中移除该数据
7. WHEN 缓冲区数据写入失败 THEN 系统应保留数据并在下次尝试时重试

### 需求 4: 任务执行器重构

**用户故事**: 作为系统，我需要一个独立的任务执行器组件来管理任务的完整生命周期。

#### 验收标准

1. WHEN 任务执行器创建 THEN 系统应初始化状态机、缓冲区和数据持久化层
2. WHEN 任务开始 THEN 执行器应创建任务记录、初始化状态并启动工作线程
3. WHEN 步骤执行 THEN 执行器应记录步骤到缓冲区并在完成时持久化
4. WHEN 任务停止 THEN 执行器应停止工作线程、刷新缓冲区并更新最终状态
5. WHEN 任务完成 THEN 执行器应清理资源、关闭线程并释放内存
6. WHEN 执行器销毁 THEN 系统应确保所有数据已持久化
7. WHEN 执行器出错 THEN 系统应记录错误、保存当前状态并安全关闭

### 需求 5: 数据持久化层

**用户故事**: 作为系统，我需要一个独立的数据持久化层来统一管理所有数据库操作。

#### 验收标准

1. WHEN 持久化层初始化 THEN 系统应创建数据库连接池和事务管理器
2. WHEN 写入任务记录 THEN 持久化层应使用事务确保原子性
3. WHEN 写入步骤记录 THEN 持久化层应批量写入以提高性能
4. WHEN 更新任务状态 THEN 持久化层应使用乐观锁防止并发冲突
5. WHEN 数据库操作失败 THEN 持久化层应回滚事务并返回错误
6. WHEN 查询数据 THEN 持久化层应使用预编译语句防止 SQL 注入
7. WHEN 持久化层关闭 THEN 系统应关闭所有连接并释放资源

### 需求 6: 停止任务流程重构

**用户故事**: 作为用户，当我停止任务时，系统应确保所有已执行的步骤都被正确保存。

#### 验收标准

1. WHEN 用户点击停止按钮 THEN 系统应立即设置停止标志并禁用停止按钮
2. WHEN 停止标志设置 THEN 系统应停止接受新的步骤信号
3. WHEN 工作线程检测到停止标志 THEN 线程应完成当前步骤后停止
4. WHEN 当前步骤完成 THEN 系统应将步骤写入数据库
5. WHEN 所有步骤写入完成 THEN 系统应将任务状态更新为 STOPPED
6. WHEN 任务状态更新完成 THEN 系统应通知 UI 更新显示
7. WHEN 停止流程完成 THEN 系统应在 UI 显示"已停止"并显示已执行的步骤数

### 需求 7: 错误恢复机制

**用户故事**: 作为系统，我需要能够从各种错误情况中恢复，确保数据完整性。

#### 验收标准

1. WHEN 数据库连接断开 THEN 系统应自动重连并重试操作
2. WHEN 磁盘空间不足 THEN 系统应停止任务并通知用户
3. WHEN 数据写入失败 THEN 系统应将数据写入备份文件
4. WHEN 系统崩溃 THEN 系统应在重启时检测未完成的任务
5. WHEN 检测到未完成任务 THEN 系统应将其状态标记为 CRASHED
6. WHEN 备份文件存在 THEN 系统应在启动时尝试恢复数据
7. WHEN 恢复成功 THEN 系统应删除备份文件并记录恢复日志

### 需求 8: 线程安全保证

**用户故事**: 作为系统，我需要确保多线程环境下的数据一致性和线程安全。

#### 验收标准

1. WHEN 多个线程访问共享状态 THEN 系统应使用锁保护临界区
2. WHEN 主线程和工作线程通信 THEN 系统应使用线程安全的队列
3. WHEN 信号槽连接 THEN 系统应使用 Qt.QueuedConnection 确保线程安全
4. WHEN 访问数据库 THEN 系统应使用连接池避免并发冲突
5. WHEN 修改任务状态 THEN 系统应使用原子操作确保一致性
6. WHEN 线程退出 THEN 系统应确保所有资源已释放
7. WHEN 检测到死锁 THEN 系统应记录错误并强制终止相关线程

### 需求 9: 性能优化

**用户故事**: 作为系统，我需要在保证数据完整性的同时优化性能。

#### 验收标准

1. WHEN 写入步骤数据 THEN 系统应使用批量插入减少数据库操作次数
2. WHEN 查询任务列表 THEN 系统应使用索引加速查询
3. WHEN 更新任务状态 THEN 系统应只更新必要的字段
4. WHEN 缓冲区达到阈值 THEN 系统应触发批量写入
5. WHEN 数据库空闲 THEN 系统应执行 VACUUM 优化数据库
6. WHEN 内存使用过高 THEN 系统应清理缓存并释放内存
7. WHEN 性能监控 THEN 系统应记录关键操作的耗时

### 需求 10: 可测试性

**用户故事**: 作为开发者，我需要能够轻松测试任务执行和数据持久化的各个方面。

#### 验收标准

1. WHEN 测试任务执行 THEN 系统应提供模拟的任务执行器
2. WHEN 测试数据持久化 THEN 系统应支持使用内存数据库
3. WHEN 测试状态转换 THEN 系统应提供状态机的独立测试接口
4. WHEN 测试错误处理 THEN 系统应支持注入错误模拟失败场景
5. WHEN 测试并发 THEN 系统应提供多线程测试工具
6. WHEN 测试性能 THEN 系统应提供性能基准测试
7. WHEN 测试完成 THEN 系统应生成测试报告和覆盖率统计

## 架构约束

1. **必须保持数据库向后兼容**: 新架构必须能读取旧版本的数据
2. **必须支持数据迁移**: 提供工具将旧数据迁移到新架构
3. **必须保持 API 兼容**: 外部调用接口不应有破坏性变更
4. **必须支持回滚**: 如果新架构有问题，应能回滚到旧版本

## 非功能需求

### 可靠性
- 数据丢失率: 0%
- 状态一致性: 100%
- 系统崩溃恢复: 自动

### 性能
- 步骤写入延迟: < 50ms
- 任务状态更新: < 10ms
- 停止任务响应: < 100ms

### 可维护性
- 代码模块化: 每个组件职责单一
- 测试覆盖率: > 80%
- 文档完整性: 所有公共 API 都有文档

## 实施策略

### 阶段 1: 核心架构（高优先级）
- 需求 1: 任务状态机
- 需求 2: 同步数据持久化
- 需求 5: 数据持久化层

### 阶段 2: 执行流程（高优先级）
- 需求 4: 任务执行器重构
- 需求 6: 停止任务流程重构
- 需求 8: 线程安全保证

### 阶段 3: 容错和优化（中优先级）
- 需求 3: 步骤缓冲区机制
- 需求 7: 错误恢复机制
- 需求 9: 性能优化

### 阶段 4: 测试和文档（中优先级）
- 需求 10: 可测试性
- 集成测试
- 文档编写

## 成功标准

重构成功的标准：

1. ✅ 停止任务时，所有已执行步骤都被保存
2. ✅ 任务状态始终正确（不再出现 UNKNOWN）
3. ✅ 数据库操作失败时有明确的错误提示
4. ✅ 系统崩溃后能自动恢复数据
5. ✅ 所有核心功能都有单元测试
6. ✅ 性能不低于当前实现
7. ✅ 用户界面无感知（除了 bug 修复）

## 风险评估

### 高风险
- 数据迁移可能失败
- 性能可能下降
- 引入新的 bug

### 缓解措施
- 充分测试数据迁移
- 性能基准测试
- 分阶段发布，每个阶段都可回滚
